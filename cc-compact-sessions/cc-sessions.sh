#!/bin/bash

# Configuration flags
ONLY_LAST_COUNT_SESSIONS=30          # Show only last N sessions (0 = show all)
FILTER_OUT_EMPTY_SESSIONS=true       # Skip sessions with no meaningful content
MIN_MESSAGES_TO_SHOW=0               # Skip sessions with fewer than N messages (0 = show all)
SHOW_WARMUP_SESSIONS=false           # Show sessions that only contain "Warmup" message

# Check if a session number was provided as argument
SESSION_NUMBER="$1"

if ! command -v jq &> /dev/null; then
  echo "jq is required but not installed. Install it with: sudo apt install jq"
  exit 1
fi

CLAUDE_DIR="$HOME/.claude"
HISTORY_FILE="$CLAUDE_DIR/history.jsonl"

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
  echo "Error: This script only works inside a git repository"
  echo "Current directory: $(pwd)"
  exit 1
fi

# Get git repository root
REPO_ROOT=$(git rev-parse --show-toplevel)
PROJECT_DIR="$CLAUDE_DIR/projects/$(echo "$REPO_ROOT" | sed 's|/_|--|g; s|/|-|g')"

if [ ! -f "$HISTORY_FILE" ]; then
  echo "Claude Code history file not found: $HISTORY_FILE"
  exit 1
fi

if [ ! -d "$PROJECT_DIR" ]; then
  echo "Claude Code project directory not found: $PROJECT_DIR"
  echo "Repository root: $REPO_ROOT"
  exit 1
fi

now=$(date +%s)
now_ms=$((now * 1000))

temp_sessions=$(mktemp)
trap "rm -f $temp_sessions" EXIT

# Find all session files and sort by modification time (newest first)
find "$PROJECT_DIR" -name "*.jsonl" -type f -not -name "agent-*" -printf "%T@ %p\n" 2>/dev/null | \
  sort -rn | \
  while read -r mtime session_file; do
    session_id=$(basename "$session_file" .jsonl)

    if ! grep -q "^$session_id|" "$temp_sessions" 2>/dev/null; then
      # Use file modification time as timestamp
      mtime_ms=$(echo "$mtime * 1000" | bc | cut -d. -f1)
      echo "$session_id|$mtime_ms" >> "$temp_sessions"
    fi
  done

session_count=0
declare -a session_ids
declare -a session_files
declare -a session_timestamps

while IFS='|' read -r session_id last_timestamp; do
  # Apply session count limit if configured
  if [ $ONLY_LAST_COUNT_SESSIONS -gt 0 ] && [ $session_count -ge $ONLY_LAST_COUNT_SESSIONS ]; then
    break
  fi
  diff_ms=$((now_ms - last_timestamp))
  diff_seconds=$((diff_ms / 1000))

  if [ $diff_seconds -lt 60 ]; then
    time_ago="${diff_seconds}s ago"
  elif [ $diff_seconds -lt 3600 ]; then
    minutes=$((diff_seconds / 60))
    time_ago="${minutes}m ago"
  elif [ $diff_seconds -lt 86400 ]; then
    hours=$((diff_seconds / 3600))
    time_ago="${hours}h ago"
  else
    days=$((diff_seconds / 86400))
    time_ago="${days}d ago"
  fi

  session_file="$PROJECT_DIR/$session_id.jsonl"
  user_count=$(grep -c '"type":"user"' "$session_file" 2>/dev/null)
  assistant_count=$(grep -c '"type":"assistant"' "$session_file" 2>/dev/null)

  # Calculate token percentage - optimized: only process usage lines, find last with tokens > 0
  token_pct=""
  last_valid_usage=$(grep -F '"usage"' "$session_file" 2>/dev/null | grep -v '"input_tokens":0,"output_tokens":0' | tail -1 | jq -c '.message.usage' 2>/dev/null)

  if [ -n "$last_valid_usage" ]; then
    total=$(echo "$last_valid_usage" | jq -r '(.input_tokens // 0) + (.cache_read_input_tokens // 0) + (.output_tokens // 0)')
    if [ "$total" -gt 0 ]; then
      # Claude Code uses: 200K - system_prompt (~7K) - buffer (13K) = ~180K available
      pct=$((total * 100 / 180000))

      # Color coding based on usage
      if [ $pct -ge 90 ]; then
        token_pct="\033[35m$pct%\033[0m"  # Purple for >=90% (high)
      elif [ $pct -ge 80 ]; then
        token_pct="\033[33m$pct%\033[0m"  # Yellow for >=80% (warning)
      else
        token_pct="$pct%"                  # Normal for <80%
      fi
    fi
  fi

  # Get first real user message (string content only, not tool results)
  first_msg=$(jq -rs '
    [.[] | select(.type == "user") | .message.content | select(type == "string") | select(. != null and . != "Warmup" and . != "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.")][0]
  ' "$session_file" 2>/dev/null)

  # Flag to track if this is a command
  is_command=false

  # Check if first message starts with command tags
  if [[ "$first_msg" =~ ^\<command-message\> ]] || [[ "$first_msg" =~ ^\<command-name\> ]]; then
    is_command=true
    # This is a custom command - extract command name and args
    cmd=""
    if [[ "$first_msg" =~ \<command-name\>/?([^<]+)\</command-name\> ]]; then
      cmd="${BASH_REMATCH[1]}"
    elif [[ "$first_msg" =~ \<command-message\>([^\ ]+)\ is\ running ]]; then
      cmd="${BASH_REMATCH[1]}"
    fi

    # Extract command arguments
    cmd_args=""
    if [[ "$first_msg" =~ \<command-args\>([^<]+)\</command-args\> ]]; then
      cmd_args="${BASH_REMATCH[1]}"
    fi

    # Build title from command
    if [ -n "$cmd" ]; then
      if [ -n "$cmd_args" ]; then
        title="/$cmd $cmd_args"
      else
        title="/$cmd"
      fi
    fi

    # Special handling for /clear - show next message
    if [ "$cmd" = "clear" ]; then
      second_msg=$(jq -r '
        select(.type == "user") |
        .message.content |
        select(. != null and . != "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to." and (. | contains("<command-message>") | not) and (. | contains("<local-command-stdout>") | not))
      ' "$session_file" 2>/dev/null | head -1 | tr '\n' ' ' | sed 's/  */ /g; s/^ //; s/ $//')
      if [ -n "$second_msg" ]; then
        title="/clear + $second_msg"
      fi
    fi

    # Special handling for /ide - show actual user message
    if [ "$cmd" = "ide" ]; then
      real_msg=$(jq -r '
        select(.type == "user") |
        select(.message.content | type == "string") |
        .message.content |
        select(. != null and . != "Warmup" and (. | startswith("<command-name>") | not))
      ' "$session_file" 2>/dev/null | head -1 | tr '\n' ' ' | sed 's/  */ /g; s/^ //; s/ $//')
      if [ -n "$real_msg" ]; then
        title="$real_msg"
        is_command=false  # Don't show as command since we're showing user message
      fi
    fi
  else
    # Not a command - use the message as title
    title=$(echo "$first_msg" | tr '\n' ' ' | sed 's/  */ /g; s/^ //; s/ $//')
  fi

  # Apply filters based on configuration

  # Filter out empty sessions if configured
  if [ "$FILTER_OUT_EMPTY_SESSIONS" = true ] && { [ -z "$title" ] || [ "$title" = "[" ] || [ "$title" = "null" ]; }; then
    continue
  fi

  # Filter out warmup sessions if configured
  if [ "$SHOW_WARMUP_SESSIONS" = false ] && [ "$title" = "Warmup" ]; then
    continue
  fi

  # Filter by minimum message count if configured
  total_msgs=$((user_count + assistant_count))
  if [ $MIN_MESSAGES_TO_SHOW -gt 0 ] && [ $total_msgs -lt $MIN_MESSAGES_TO_SHOW ]; then
    continue
  fi

  # Remove pasted text prefix if present
  if [[ "$title" =~ ^\[Pasted\ text\ #[0-9]+\ \+[0-9]+\ lines\] ]]; then
    title=$(echo "$title" | sed 's/\[Pasted text #[0-9]\+ +[0-9]\+ lines\]  *//')
  fi

  # Truncate at word boundary if too long
  if [ ${#title} -gt 60 ]; then
    title=$(echo "$title" | cut -c1-57)
    # Find last space and truncate there
    if [[ "$title" =~ (.*)\ [^\ ]*$ ]]; then
      title="${BASH_REMATCH[1]}..."
    else
      title="$title..."
    fi
  fi

  # Extract short session ID (last 12 chars)
  short_id="${session_id: -12}"

  # Store session info in arrays
  session_ids[$session_count]="$session_id"
  session_files[$session_count]="$session_file"
  session_timestamps[$session_count]="$last_timestamp"

  # Apply blue color to commands and add token percentage
  if [ -n "$token_pct" ]; then
    token_display=" · $token_pct"
  else
    token_display=""
  fi

  # Build and print the line with colors
  if [ "$is_command" = true ]; then
    echo -e "$(printf "%2d) %s · %8s · %3s you · %3s cc%s · \033[34m%s\033[0m" "$((session_count + 1))" "$short_id" "$time_ago" "$user_count" "$assistant_count" "$token_display" "$title")"
  else
    echo -e "$(printf "%2d) %s · %8s · %3s you · %3s cc%s · %s" "$((session_count + 1))" "$short_id" "$time_ago" "$user_count" "$assistant_count" "$token_display" "$title")"
  fi

  ((session_count++))
done < "$temp_sessions"

# If no session number was provided, ask interactively
if [ -z "$SESSION_NUMBER" ]; then
  echo ""
  read -p "Select session number (1-$session_count, or press Enter to exit): " SESSION_NUMBER

  # Exit if user just pressed Enter
  if [ -z "$SESSION_NUMBER" ]; then
    exit 0
  fi
fi

# Show detailed info for selected session
if [ -n "$SESSION_NUMBER" ]; then
  index=$((SESSION_NUMBER - 1))

  if [ $index -lt 0 ] || [ $index -ge $session_count ]; then
    echo ""
    echo "Invalid session number. Please choose between 1 and $session_count"
    exit 1
  fi

  selected_id="${session_ids[$index]}"
  selected_file="${session_files[$index]}"
  selected_timestamp="${session_timestamps[$index]}"

  # Count messages
  user_msgs=$(grep -c '"type":"user"' "$selected_file" 2>/dev/null)
  assistant_msgs=$(grep -c '"type":"assistant"' "$selected_file" 2>/dev/null)

  # Get first and last message timestamps
  first_ts=$(jq -r 'select(.timestamp != null) | .timestamp' "$selected_file" 2>/dev/null | head -1)
  last_ts=$(jq -r 'select(.timestamp != null) | .timestamp' "$selected_file" 2>/dev/null | tail -1)

  # Convert ISO timestamps to milliseconds
  if [ -n "$first_ts" ]; then
    first_ts_ms=$(date -d "$first_ts" +%s%3N 2>/dev/null || echo "$selected_timestamp")
  else
    first_ts_ms="$selected_timestamp"
  fi

  if [ -n "$last_ts" ]; then
    last_ts_ms=$(date -d "$last_ts" +%s%3N 2>/dev/null || echo "$selected_timestamp")
  else
    last_ts_ms="$selected_timestamp"
  fi

  # Calculate time ago for created and last message
  created_diff_ms=$((now_ms - first_ts_ms))
  created_diff_seconds=$((created_diff_ms / 1000))

  last_diff_ms=$((now_ms - last_ts_ms))
  last_diff_seconds=$((last_diff_ms / 1000))

  # Format created time ago
  if [ $created_diff_seconds -lt 60 ]; then
    created_ago="${created_diff_seconds}s ago"
  elif [ $created_diff_seconds -lt 3600 ]; then
    created_minutes=$((created_diff_seconds / 60))
    created_ago="${created_minutes}m ago"
  elif [ $created_diff_seconds -lt 86400 ]; then
    created_hours=$((created_diff_seconds / 3600))
    created_ago="${created_hours}h ago"
  else
    created_days=$((created_diff_seconds / 86400))
    created_ago="${created_days}d ago"
  fi

  # Format last message time ago
  if [ $last_diff_seconds -lt 60 ]; then
    last_ago="${last_diff_seconds}s ago"
  elif [ $last_diff_seconds -lt 3600 ]; then
    last_minutes=$((last_diff_seconds / 60))
    last_ago="${last_minutes}m ago"
  elif [ $last_diff_seconds -lt 86400 ]; then
    last_hours=$((last_diff_seconds / 3600))
    last_ago="${last_hours}h ago"
  else
    last_days=$((last_diff_seconds / 86400))
    last_ago="${last_days}d ago"
  fi

  echo ""
  echo "- session file: $selected_file"
  echo "- your messages: $user_msgs"
  echo "- claude code messages: $assistant_msgs"
  echo "- created at: $created_ago"
  echo "- last message at: $last_ago"
  echo ""

  # Ask if user wants to compact this session
  read -p "Compact this session? (y/N): " compact_choice

  if [[ "$compact_choice" =~ ^[Yy]$ ]]; then
    echo ""

    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    COMPACTOR_SCRIPT="$SCRIPT_DIR/cc-compact-session.sh"

    if [ ! -f "$COMPACTOR_SCRIPT" ]; then
      echo "Error: cc-compact-session.sh not found"
      echo "Expected location: $COMPACTOR_SCRIPT"
      exit 1
    fi

    echo "Step 1/2: Parsing session to markdown..."
    bash "$COMPACTOR_SCRIPT" --parse "$selected_id"

    if [ $? -ne 0 ]; then
      echo "Error: Failed to parse session"
      exit 1
    fi

    parsed_file="$REPO_ROOT/cc-session-parsed-${selected_id:0:12}.md"

    echo ""
    echo "Step 2/2: Compacting via Claude Code..."
    bash "$COMPACTOR_SCRIPT" --compact "$parsed_file"
  fi
fi
